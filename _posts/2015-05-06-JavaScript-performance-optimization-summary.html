---
layout: default
title: JavaScript性能优化知识点总结
category: skill
tags: JavaScript
excerpt: JavaScript的性能问题是需要被格外关注的，这就需要我们在编写JavaScript程序时多注意一些细节。同时有一些常见的方法可以让你的JavaScript代码节约一些字节，同时提高可读性。
---
<h3>{{page.title}}</h3>
<p class="author">
    作者：<em class="color-pink">Cynthia</em> 
    <span class="normal-date"> · {{ page.date | date: "%Y年%m月%d日" }}</span>
</p>
<article>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript的性能问题是需要被格外关注的，这就需要我们在编写JavaScript程序时多注意一些细节。同时有一些常见的方法可以让你的JavaScript代码节约一些字节，同时提高可读性。一些总结如下：</p>
	<h4>减少全局查找</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些。</p>
	<pre>
	<code class="javascript">
	//获取当前页面地址和主机域名
	function getLocation(){
	  alert(window.location.href + window.location.host);
	}
	//最好的方式如下，先用一个变量把全局变量保存起来
	function getLocation(){
	  var location = window.location;
	  alert(location.href + location.host);
	}
	</code>
	</pre>
	<h4>条件分支</h4>
	<ol>
		<li>将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数</li>
		<li>在同一条件的子条件分支&gt;2的情况时，使用switch优于if:switch分支选择的效率高于if,在IE下尤为明显，IE下switch的执行时间约为if的一半。</li>
		<li>使用三元运算符替代非此即彼的if判断。示例如下：</li>
	</ol>
	<pre>
	<code class="javascript">
	if(age > legalAge){
	   canDrive = true;
	}else{
	   canDrive = false;
	}
	//可以替换为：
	var candrive = (age > legalAge) ? true : false;
	</code>
	</pre>
	<h4>默认值的分配</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于变量未赋值时定义默认值的情况，与其使用if语句判断，不如使用一种更简洁的方式实现：</p>
	<pre>
	<code class="javascript">
	function displayVal(limit){
	  var length;
	  if(limit){
	    length = limit;
	  }else{
	    length = 10;
	  }
	  for(var i = 0; i++; i <= length){
	    ···
	  }
	}
	//更简洁的方式
	function displayVal(limit){
	  var length = limit || 10;
	  for(var i = 0; i++; i <= length){
	    ···
	  }
	}
	</code>
	</pre>
	<h4>定时器</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果针对的是不断运行的代码，不应该使用<code>setTimeout</code>，而应该是用<code>setInterval</code>，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器。</p>
	<pre>
	<code class="javascript">
	var timeoutTimes = 0;
	function timeout(){
	  timeoutTimes++;
	  if(timeoutTimes < 10){
	    setTimeout(timeout,10);
	  }
	}	
	timeout();
	//可以转化为
	var intervalTimes = 0;
	function interval(){
	  intervalTimes++;
	  if(intervalTimes >= 10){
	    clearInterval(interv);
	  }
	}
	var interv = setInterval(interval,10);
	</code>
	</pre>
	<h4>数字转换成字符串</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般最好用""+1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，从性能上来说：<code>(""+1)&gt;String()&gt;.toString()&gt;new String()</code></p>
	<h4>浮点数转换成整型</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许多人喜欢使用parseInt(),其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor或者Math.round()。</p>
	<h4>各种类型转换</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果定义了toString()方法来进行类型转换的话，推荐显式调用toString(),因为内部的操作在尝试所有的可能性之后，会尝试对象的toString()方法，尝试能否转化为String,所以直接调用这个方法效率会更高。</p>
	<pre>
	<code class="javascript">
	var myVar = "3.14159", 
	str = "" + myVar, //to string
	i_int = ~~myVar, //to integer
	f_float = 1*myVar, // to float
	b_bool = !!myVar, /**to boolean any string with length and any number except 0 are true*/
	array = [myVar]; //to array
	</code>
	</pre>
	<h4>多个类型声明</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在JavaScript中所有变量都可以使用单个var语句来声明，这样可将声明组合在一起，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。</p>
	<h4>字符串连接</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要连接多个字符串，应该少使用+=，如</p>
	<pre>
	<code class="javascript">
	s += a;
	s += b;
	s += c;
	//应该写成
	s += a + b + c;
	</code>
	</pre>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而如果是收集字符串，比如多次对同一个字符串进行 += 操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来。</p>
	<pre><code class="javascript">
	var buf = [];
	for(var i = 0; i < 100; i ++){
	  buf.push(i.toString());
	}
	var all = buf.join("");
	</code></pre>
	<h4>变量递增/递减/乘/除</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想递增或递减一个变量，类似下面：</p>
	<pre><code class="javascript">
	growCount = growCount + 1;
	shrinkCount = shrinkCount - 1;
	//可以以下面的方式书写：
	growCount ++;
	shrinkCount --;
	//乘除也可以以这种方式书写：
	moreSweets *=  5;
	lessApple /= 2;
	</code></pre>
	<h4>插入迭代器</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如 <code>var name = values[i]; i++;</code>前面两条语句可以写成<code>var name = values[i++];</code></p>
	<h4>使用直接量</h4>
	<pre><code class="javascript">
	var aTest = new Array();
	//替换为
	var aTest = [];

	var aTest = new Object;
	//替换为
	var aTest = {};

	var reg = new RegExp();
	//替换为
	var reg = /.../;
	</code></pre>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要创建具有一些特性的一般对象，也可以使用字面量，如下：</p>
	<pre><code class="javascript">
	var oFruit = new O;
	oFruit.color = "red";
	oFruit.name = "apple";
	//前面的代码可用对象字面量来改写成这样：
	var oFruit = {color:"red", name:"apple"};
	</code></pre>
	<h4>使用DocumentFragment优化多次append</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦需要更新DOM，请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。</p>
	<pre><code class="javascript">
	for(var i = 0; i < 1000; i++){
	  var el = document.createElement('p');
	  el.innerHTML = i;
	  document.body.appendChild(el);
	}
	//可替换为：
	var frag = document.createDocumentFragment();
	for(var i = 0; i < 1000; i++){
	  var el = document.createElement('p');
	  el.innerHTML = i;
	  frag.appendChild(el);
	}
	document.body.appendChild(frag);
	</code></pre>
	<h4>使用一次innerHTML赋值代替构建dom元素</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。</p>
	<pre><code class="javascript">
	var frag = document.createDocumentFragment();
	for(var i = 0; i < 1000; i++){
	  var el = document.createElement('p');
	  el.innerHTML = i;
	  frag.appendChild(el);
	}
	document.body.appendChild(frag);
	//可替换为：
	var html = [];
	for(var i = 0; i < 1000; i++){
	  html.push('&lt;p&gt;'+ i + '&lt;/p&gt;');
	}
	document.body.innerHTML = html.join("");
	</code></pre>
	<h4>通过模板元素clone，替代createElement</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人喜欢在JavaScript中使用document.write来给页面生成内容。事实上这样的效率很低，如果需要直接插入HTML,可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。通过我们可能会使用字符串直接写HTML来创建节点。这样做有两个弊端，首先无法保证代码的有效性；其次字符串操作效率低，所以应该是用document.createElement()方法，而如果文档中存在现成的样板节点，应该是用cloneNode()方法。因为使用createElement()方法后，你需要设置多次元素的属性，使用cloneNode()则可减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点。</p>
	<pre><code class="javascript">
	var frag = document.createDocumentFragment();
	for(var i = 0; i < 1000; i++){
	  var el = document.createElement('p');
	  el.innerHTML = i;
	  frag.appendChild(el);
	}
	document.body.appendChild(frag);
	//替换为
	var frag = document.createDocumentFragment();
	var pEl = document.getElementsByTagName('p')[0];
	for(var i = 0; i < 1000; i ++){
	  var el = pEl.cloneNode(false);
	  el.innerHTML = i;
	  frag.appendChild(el);
	}
	document.body.appendChild(frag);
	</code></pre>
	<h4>使用firstChild和nextSibling代替childNodes遍历dom元素</h4>
	<pre><code class="javascript">
	var nodes = element.childNodes;
	for(var i = 0; i < nodes.length;i++){
	  var node = nodes[i];//······
	}
	//可以替换为：
	var node = element.firstChild;
	while(node){
	  ······
      node = node.nextSibling;
	}
	</code></pre>
</article>
<div class="line"></div>
<div class="tag-list">
	{% for tag in page.tags %}
    <a href="{{ site.baseurl}}/show_by_tag/?tag={{tag}}">{{tag}}</a>
	{% endfor%}
</div>