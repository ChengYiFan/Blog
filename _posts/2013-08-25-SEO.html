---
layout: default
title: 雅虎优化前端性能的34条建议
category: skill
tags: SEO
excerpt: 前端是涉及的内容是庞大的，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。<br/>这篇文章详细介绍了雅虎优化前端性能的34条建议。
---
<h3>{{page.title}}</h3>
<p class="author">
    作者：<em class="color-pink">Cynthia</em> 
    <span class="normal-date"> · {{ page.date | date: "%Y年%m月%d日" }}</span>
</p>
<article>
	<h5>1、尽量减少HTTP请求次数</h5>
    <p>终端用户响应的时间中，有80%用于下载各项内容。包括：</p>
    <ul>
    	<li>图像</li>
    	<li>样式表</li>
		<li>脚本</li>
		<li>Flash</li>
		<li>等等</li>
    </ul>
    <p>所以，通过减少页面中的元素可以减少HTTP请求的次数。这是提高网页速度的关键步骤。</p>
    <p>减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？</p>
    <ul>
    	<li>合并文件。通过把所有的脚本放到一个文件中来减少HTTP请求。如可以简单的把所有CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修改。这可能会相对麻烦点，但即使如此也要把这个方法作为改善页面性能的重要一步。</li>
    	<li>CSS Sprites是减少图像请求的有效方法。把所有的背景图都放到一个图片文件中，然后通过CSS的background-image和background-position属性来显示图片的不同部分。</li>
    	<li>图片地图。是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可以减少HTTP请求次数。图片地图只有在图片的所有组成部分在页面中是紧挨在一起的时候才能使用，如导航栏。确定图片的坐标可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法。</li>
    	<li>内联图像。是使用data:URL scheme的方法把图像数据加载到页面中。这可能会增加页面的大小。把内联图像放到样式表（可缓存）中可以减少HTTP请求同时又避免增加页面文件的大小。但内联图像现在还没有得到主流浏览器的支持。</li>
    </ul>
    <p>减少页面的HTTP请求次数是你首先要做的一步。这是改进首次访问用户等待时间的最重要的方法。“HTTP请求在无缓存的情况下占去了40%到60%的响应时间。让那些初次访问你网站的人获得更加快速的体验吧！”</p>
    <h5>2、减少DNS查找次数</h5>
    <p>域名系统（DNS）提供了域名和IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的IP地址会花费20到120毫秒的时间。而且在这个过程中浏览器什么都不会做直到DNS查找完毕。</p>
    <ul>
        <li>缓存DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的ISP提供商或者本地局域网控制，但是它同样会在用户使用的计算机上产生缓存。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。（windows系统中有DNS Client Service，DNS信息会保留在操作系统的DNS缓存中）</li>
        <li>当客户端中的DNS缓存都为空时（浏览器和操作系统都为空），DNS查找的次数和页面中主机名的数量相同。这其中包括页面中URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。</li>
        <li>减少主机名的数量还可以减少页面中并行下载的数量。减少DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的原则是把这些页面中的内容分割成至少两部分但不超过四部分。这种结果就是在减少DNS查找次数和保持较高程度并行下载两者之间的权衡了。</li>
    </ul>
    <h5>3、避免跳转</h5>
    <p>跳转是使用301和302代码实现的。下面是一个响应代码为301的HTTP头：</p>
    <pre><code>
    HTTP/1.1 301 Moved Permanently
    Location: http://example.com/newuri
    Content-Type: text/html
    </code></pre>
    <p>浏览器会把用户指向到Location中指定的URL。头文件中的所有信息在一次跳转中都是必须的，内容部分可以为空。不管他们的名称，301和302响应都不会被缓存除非增加一个额外的头选项，如Expires或者Cache-Control来指定它缓存。<meat/>元素的刷新标签和JavaScript也可以实现URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的3XXHTTP状态代码，这主要是为了确保“后退”按钮可以正确地使用。</p>
    <p>但是要记住，<em class="c-pink">跳转会降低用户体验</em>。在用户和HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在HTML文件被加载前任何文件（图像、Flash等）都不会被下载。</p>
    <p>有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。这种现象发生在URL本该有斜杠(/)却被忽略掉时。例如，当访问<a href="http://astrology.yahoo.com/astrology">http://astrology.yahoo.com/astrology</a> 时，实际上返回的是一个包含301代码的跳转，它指向的是<a href="http://astrology.yahoo.com/astrology/">http://astrology.yahoo.com/astrology/</a>(注意末尾的斜杠)。在Apache服务器中可以使用Alias或者mod_rewrite或者the DirectorySlash来避免</p>
    <p>连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类型）来进行跳转。﻿使用跳转来实现两个网站的切换十分简单，需要的代码量也不多。尽管使用这种方法对于开发者来说可以降低复杂度，但是它同样降低用户体验。一个可替代方法就是如果两者在同一台服务器上时使用Alias 和 mod_rewrite来实现。如果是因为域名的不同而采用跳转，那么可以通过使用Alisa或者mod_rewrite 建立CNAME （保存一个域名和另外一个域名之间关系的DNS记录来替代）。</p>
    <h5>4、可缓存的AJAX</h5>
    <p> Ajax经常被提及的一个好处就是由于其从后台服务器传输信息的异步性而为用户带来的反馈的即时性。但是，使用Ajax并不能保证用户不会在等待异步的Javascript和XML响应上花费时间。在很多应用中，用户是否需要等待取决于Ajax如何来使用。例如，在一个基于Web的Email客户端中，用户必须等待Ajax返回符合他们条件的邮件查询结果。<em class="c-pink">“异步”并不意味着“即时”</em>，这很重要。</p>
    <p>为了提高性能，优化Ajax响应是很重要的。提高Ajax性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看Add an Expires or a Cache-Control Header。其它的几条规则也同样适用于Ajax：</p>
    <ul>
        <li>Gizp压缩文件</li>
        <li>减少DNS查找次数</li>
        <li>精简Javascript</li>
        <li>避免跳转</li>
        <li>配置ETags</li>
    </ul>
    <p>即使你的Ajax响应式动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来。这样做可以使你的Web2.0应用程序更加快捷。</p>
    <h5>5、推迟加载内容</h5>
    <p>你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时必需首先加载的？哪些内容和结构可以稍后再加载？</p>
    <p>把整个过程按照onload事件分隔成两部分，Javascript是个理想的选择。例如，如果你有用于实现拖放和动画的Javascript，那么它就可以等待稍后加载，因为页面上的拖放元素是在初始化呈现之后才发生的。其他的如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以推迟加载。</p>
    <p>工具可以节省你的工作量：YUI Image Loader 可以帮助你推迟加载折叠部分的图片，YUI Get utility 是包含JS 和 CSS的便捷方法。比如你可以打开Firebug 的Net选项卡看一下Yahoo的首页。</p>
    <p>当性能目标和其他网站开发实践一致时就会相得益彰。这种情况下，通过程序提高网站性能的方法告诉我们，在支持JavaScript的情况下﻿，可以先去除用户体验，不过这要保证你的网站在没有Javascript的情况下也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。</p>
    <h5>6、预加载</h5>
    <p> 预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。</p>
    <p>下面提供了几种预加载方法：</p>
    <ul>
        <li>无条件加载：触发onload事件时，直接加载额外的页面内容。以 Google.com 为例，你可以看一下它的spirit image 图像是怎样在onload 中加载的。这个spirit image图像在google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。</li>
        <li>有条件加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可能出在用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部分内容来避免这种结果的出现。在你的旧站中利用浏览器的空余时间加载新站中用到的图像和脚本来提高访问速度。</li>
    </ul>
    <h5>7、减少DOM元素的数量</h5>
    <p>一个复杂的页面意味着需要下载更多的数据，同时也意味着JavaScript遍历DOM的效率越慢。比如当你增加一个事件句柄时在500和5000个DOM元素中循环效果肯定是不一样的。</p>
    <p>大量的DOM元素的存在意味着页面中由可以不用移除内容只需替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的<div>元素呢？也许会存在一个适合或者在语义上更贴切的标签可以供你使用。</p>
    <p>YUI CSS utilities 可以给你的布局带来巨大帮助：grids.css 可以帮你实现整体布局，font.css和reset.css可以帮助你移除浏览器默认格式。它提供了一个重新审视你页面中标签的机会，比如只有在语义上有意义时才使用<div>，而不是因为它具有换行效果才使用它。</p>
    <p>DOM元素数量很容易计算出来，只需要在Firebug的控制台内输入：</p>
    <pre><code>document.getElementsByTagName('*').length;  </code></pre>
    <p>那么多少个ODM元素算是多呢？这可以对照有很好标记使用的类似页面。比如Yahoo! 主页是一个内容非常多的页面，但是它只使用了700个元素（HTML标签）。</p>
    <h5>8、根据域名划分页面内容</h5>
    <p>把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于DNS查找带来的影响你首先要确保你使用的域名数量在2个到4个之间。例如，你可以把用到的HTML内容和动态内容放在www.example.org上，而把页面各种组件（图片、脚本、CSS）分别存放在statics.example.org上。你可在Tenni Theurer 和 Partty Chi合写的文章Maximizing Parallel Downloads in the Carpool Lane 找到更多相关信息。</p>
    <h5>9、使iframe得数量最小</h5>
    <p>iframe 元素可以在父文档中插入一个新的HTML文档。了解iframe 的工作原理后才能更加有效地使用它，这一点很重要。</p>
    <p>iframe的优点：</p>
    <ul>
        <li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li>
        <li>Security  sandbox</li>
        <li>并行加载脚本</li>
    </ul>
    <p>iframe的缺点：</p>
    <ul>
        <li>即使内容为空，加载也需要时间</li>
        <li>会阻止页面加载</li>
        <li>没有语义</li>
    </ul>
    <h5>10、不要出现404错误</h5>
    <p>HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。</p>
    <p>有些站点把404错误响应为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部Javascript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当做Javascript代码来执行。</p>
    <h5>11、使用内容分发网络</h5>
    <p>用户与你服务器的物理接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？</p>
    <p>按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任务，如在服务器间同步Session 状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。</p>
    <p>要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。</p>
    <p><em class="c-pink">内容分发网络（Content Delivery Network, CDN）</em>是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数(network hops)和响应速度最快的服务器会被选定。</p>
    <p>一些大型网络公司拥有自己的CDN，但是使用像Akamai Technologies, Mirror Image Internet,或者Limelight Networks 这样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加全球化，CDN就是实现快速响应所必须的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN 是一个只需要相对简单地修改代码以实现显著改善网站访问速度的方法。</p>
    <h5>12、为头文件指定Expires或Cache-Control</h5>
    <p>这条守则包括两方面的内容：</p>
    <ul>
        <li>对于静态内容：设置头文件过期时间Expires 的值为"Never expire"(永不过期)</li>
        <li>对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求。</li>
    </ul>
    <p>网页设计内容现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问页面的用户就意味着进行多次的HTTP请求，但是通过使用Expires文件头就可以使这些内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像文件，但是应该在所有的内容都使用它，包括脚本、样式表和Flash等。</p>
    <p>浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需要缓存多长时间。下面这个例子是个较长时间的Expires文件头，它告诉浏览器这个响应直到2010年4月15日才过期。</p>
    <pre><code>Expires: Thu, 15 Apr 2010 20:00:00 GMT</code></pre>
    <p>如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。下面这个例子是使用ExpiresDefault来设定请求时间后10年过期的文件头：</p>
    <pre><code>ExpiresDefault "access plus 10 years"</code></pre>
    <p>要切记，如果使用了Expires文件头，当页面内容改变时就必须改变内容的文件名。依Yahoo!来说我们经常使用这样的步骤：在内容的文件名中加上版本号，如yahoo_2.0.6.js。</p>
    <p>使用Expires文件头只会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时，这对减少HTTP请求次数来说是无效的，因为浏览器的缓存是空的。因此这种方法对于你网站性能的改善情况要依据他们“预缓存”存在时对你页面的点击率（“预缓存”中已经包含了页面中的所有内容）。Yahoo!建立了一套测量方法，我们发现所有的页面浏览量中75%~85%都有“预缓存”。通过使用Expires文件头，增加了缓存在浏览器中内容的数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。</p>
    <h5>13、Gzip压缩文件内容</h5>
    <p>网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。</p>
    <p>从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式：</p>
    <ul>
        <li>Accept-Encoding: gzip, deflate 如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。web服务器把压缩方式通过响应文件头中的Content-Encoding 来返回给浏览器。</li>
        <li>Content-Encoding: gzip   Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限，效果也稍稍逊色。</li>
    </ul>
    <p>Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和你的版本有关：Apachec1.3使用mod_zip，而Apache2.x使用moflate。</p>
    <p>浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。Apache模块会通过自动添加适当的Vary响应文件头来避免这种状况的出现。</p>
    <p>服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行压缩同样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都是值得的。图像和PDF文件由于已经压缩过了所以不能再进行gzip压缩。如果试图gzip压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。</p>
    <p> Gzip压缩所有可能的文件类型是减少文件体积，增加用户体验的简单方法。</p>
    <h5>14、配置ETag</h5>
    <p>Entity tags(ETags) (实体标签） 是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date(上次编辑时间)"更灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有ETag文件头的响应指定页面内容的ETag。</p>
    <pre><code>
    HTTP/1.1 200 OK
    Last-Modified:Tue, 12 Dec 2006 03:03:59 GMT
    ETag: "10c24bc-4ab-457e1c1f"
    Content-Length: 12195
    </code></pre>
    <p>稍后，如果浏览器要验证一个文件，它会使用If-None-Match文件头来把ETag传回给原始服务器。在这个例子中，如果ETag匹配，就会返回一个304状态码，这就节省了12195字节的响应。</p>
    <pre><code>
    GET/i/yahoo.gif HTTP/1.1
    Host: us.yimg.com
    If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT
    If-None-Match: "10c24bc-4ab-457e1c1f""
    HTTP/1.1 304 Not Modified
    </code></pre>
    <p>ETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行进行验证时ETag就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这会显著减少多服务器间的文件验证冲突。</p>
    <p>Apachec1.3 和 2.x中的ETag格式为inode-size-timestamp 。 即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳等都完全相同，但是在不同服务器上他们的内码也是不同的。</p>
    <p>IIS5.0和IIS6.0处理ETag的机制相似。IIS中的ETag格式为Filetimestamp:ChangeNumber。用ChangeNumber来跟踪IIS配置的改变。网站所用的不同IIS服务器间ChangeNumber也不相同。不同服务器上的Apache和IIS即使对于完全相同的内容产生的ETag也不相同，用户并不会接收到一个小而快的304响应；相反他们会接收到正常的200响应并下载全部内容。如果你的网站只放在一台服务器上，就不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用Apache和IIS产生默认的ETag配置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的内容拥有Expires文件头，无论用户什么时候点击”刷新“或者”重载“按钮都会发送相应的GET请求。</p>
    <p>如果你没有使用ETag提供的灵活的验证模式，那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容时间戳的。去掉ETag文件头会减少响应和下次请求中文件的大小。</p>
    <pre><code>FileETag none</code></pre>
    <h5>15、尽早刷新输出缓冲</h5>
    <p>当用户请求一个页面时，无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可以使用flush()方法，它允许你把已经编译好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同事处理剩余的HTML页面。这样做的效果会在后台繁忙或者前台较空闲时更加明显。</p>
    <p>输出缓冲应用最好的一个地方就是紧跟在<head/>之后，因为HTML的头部分容易生成而且头部往往包含CSS和JavaScript文件，这样浏览器就可以在后台编译剩余HTML的同时并行下载它们。例子：</p>
    <pre><code>
    …<!-- css,js-->
    </head>
    <?php flush();?>
    <body>
    …<!--content-->
    </code></pre>
    <p>为了证明使用这项技术的好处，Yahoo!搜索率先研究并完成了用户测试。</p>
    <h5>16、使用GET来完成Ajax请求</h5>
    <p>Yahoo！Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个”两步走“的过程：首先发送文件头，然后才发送数据。因此使用GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL最大长度为2K，因此如果你要发送一个超过2K的数据时就不能使用GET了。</p>
    <p>一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着”获取“数据，因此当你仅仅获取数据时使用GET更加有意义（从语义上讲也是如此），相反，发送并在服务器端保存数据时使用POST。</p>
</article>
<div class="line"></div>
<div class="tag-list">
	{% for tag in page.tags %}
    <a href="{{ site.baseurl}}/show_by_tag/?tag={{tag}}">{{tag}}</a>
	{% endfor%}
</div>